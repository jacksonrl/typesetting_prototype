import 'package:analyzer/dart/element/element2.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:code_builder/code_builder.dart' as cb;
import 'package:collection/collection.dart';
import 'package:dart_style/dart_style.dart';

const Set<String> _manualReconstructionClasses = {
  'PageSection',
  'PageLayout',
  'Document',
  'MetadataMarker',
  '_BuiltInFont',
};

String generateReconstructorFile(List<ClassElement2> proxyableClasses, List<EnumElement2> proxyableEnums) {
  final library = cb.Library((b) {
    b.directives.add(cb.Directive.partOf('package:typesetting_prototype/eval/reconstruct_document.dart'));

    final reconstructorMap = _generateReconstructorMap(proxyableClasses);
    b.body.add(reconstructorMap);

    for (final enumElement in proxyableEnums) {
      b.body.add(_generateEnumReconstructor(enumElement));
    }

    for (final classElement in proxyableClasses) {
      if (_manualReconstructionClasses.contains(classElement.name3)) {
        continue;
      }
      if (!classElement.isAbstract) {
        b.body.add(_generateClassReconstructor(classElement, proxyableClasses, proxyableEnums));
      }
    }
  });

  final emitter = cb.DartEmitter(useNullSafetySyntax: true, orderDirectives: true);
  final code = library.accept(emitter).toString();

  final header = '''
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/generate_reconstructor.dart

// ignore_for_file: unused_element

''';

  return DartFormatter(languageVersion: DartFormatter.latestLanguageVersion).format('$header\n\n$code');
}

cb.Field _generateReconstructorMap(List<ClassElement2> classes) {
  final mapEntries = <String, cb.Reference>{};
  for (final classElement in classes) {
    if (!classElement.isAbstract && classElement.allSupertypes.any((t) => t.element3.name3 == 'Widget')) {
      final scriptName = 'Script${classElement.name3}';
      final funcName = '_reconstruct${classElement.name3}';
      mapEntries[scriptName] = cb.refer(funcName);
    }
  }

  return cb.Field(
    (b) => b
      ..name = 'reconstructorMap'
      ..modifier = cb.FieldModifier.final$
      ..assignment = cb
          .literalMap(mapEntries, cb.refer('String'), cb.refer('Widget Function(Runtime, \$Instance)'))
          .code,
  );
}

cb.Method _generateEnumReconstructor(EnumElement2 enumElement) {
  final nativeName = enumElement.name3!;

  return cb.Method((b) {
    b
      ..name = '_reconstruct$nativeName'
      ..returns = cb.refer(nativeName)
      ..requiredParameters.addAll([
        cb.Parameter(
          (p) => p
            ..name = 'runtime'
            ..type = cb.refer('Runtime'),
        ),
        cb.Parameter(
          (p) => p
            ..name = 'instance'
            ..type = cb.refer('\$Instance'),
        ),
      ])
      ..body = cb.Code("return $nativeName.values[(instance.\$getProperty(runtime, 'index') as \$int).\$value];");
  });
}

cb.Method _generateClassReconstructor(
  ClassElement2 classElement,
  List<ClassElement2> allProxyClasses,
  List<EnumElement2> allProxyEnums,
) {
  final nativeName = classElement.name3!;
  final returnType = cb.refer(nativeName);

  final builder = cb.MethodBuilder()
    ..name = '_reconstruct$nativeName'
    ..returns = returnType
    ..requiredParameters.addAll([
      cb.Parameter(
        (p) => p
          ..name = 'runtime'
          ..type = cb.refer('Runtime'),
      ),
      cb.Parameter(
        (p) => p
          ..name = 'instance'
          ..type = cb.refer('\$Instance'),
      ),
    ]);

  final publicConstructors = classElement.constructors2.where((c) => !c.isPrivate).toList();
  if (publicConstructors.isEmpty) {
    builder.body = cb.Code("throw UnimplementedError('Cannot reconstruct $nativeName: no public constructors');");
    return builder.build();
  }

  var constructor = publicConstructors.firstWhereOrNull((c) => !c.isFactory && c.name3!.isEmpty);
  constructor ??= publicConstructors.firstWhereOrNull((c) => !c.isFactory);
  constructor ??= publicConstructors.first;

  final paramAssignments = <String>[];
  final bodyLines = <cb.Code>[];

  for (final param in constructor.formalParameters) {
    final paramName = param.name3!;
    final paramType = param.type;

    bodyLines.add(cb.Code("final ${paramName}Value = instance.\$getProperty(runtime, '$paramName');"));

    final reconstructionCode = _buildReconstructionLogicForType(
      '${paramName}Value',
      paramType,
      allProxyClasses,
      allProxyEnums,
    );

    bodyLines.add(cb.Code("final $paramName = $reconstructionCode;"));

    if (param.isNamed) {
      paramAssignments.add('$paramName: $paramName');
    } else {
      paramAssignments.add(paramName);
    }
  }

  final ctorName = constructor.name3!;
  final constructorName = (ctorName.isEmpty || ctorName == 'new') ? '' : '.$ctorName';

  final returnStatement = cb.Code('return $nativeName$constructorName(${paramAssignments.join(', ')});');
  bodyLines.add(returnStatement);

  builder.body = cb.Block.of(bodyLines);
  return builder.build();
}

String _buildReconstructionLogicForType(
  String valueIdentifier,
  DartType type,
  List<ClassElement2> allProxyClasses,
  List<EnumElement2> allProxyEnums,
) {
  final isNullable = type.nullabilitySuffix == NullabilitySuffix.question;
  String logic;

  if (type.isDartCoreString) {
    logic = '($valueIdentifier as \$String).\$value';
  } else if (type.isDartCoreInt) {
    logic = '($valueIdentifier as \$int).\$value';
  } else if (type.isDartCoreDouble) {
    logic = '($valueIdentifier as \$num).\$value.toDouble()';
  } else if (type.isDartCoreBool) {
    logic = '($valueIdentifier as \$bool).\$value';
  } else if (type.isDartCoreList && type is InterfaceType) {
    final genericType = type.typeArguments.first;
    final itemReconstructor = _buildReconstructionLogicForType('e', genericType, allProxyClasses, allProxyEnums);
    final nativeGenericName = genericType.element3?.name3 ?? 'dynamic';
    logic = '($valueIdentifier as \$List).\$value.map((e) => $itemReconstructor).toList().cast<$nativeGenericName>()';
  } else if (type.isDartCoreMap && type is InterfaceType) {
    final keyType = type.typeArguments.isNotEmpty ? type.typeArguments[0] : type.element3.thisType;
    final valueType = type.typeArguments.length > 1 ? type.typeArguments[1] : type.element3.thisType;

    final keyReconstructor = _buildReconstructionLogicForType('k', keyType, allProxyClasses, allProxyEnums);
    final valueReconstructor = _buildReconstructionLogicForType('v', valueType, allProxyClasses, allProxyEnums);

    final nativeKeyName = keyType.element3?.name3 ?? 'dynamic';
    final nativeValueName = valueType.element3?.name3 ?? 'dynamic';

    logic =
        '''
      ($valueIdentifier as \$Map).\$value.map(
        (k, v) => MapEntry(
          $keyReconstructor,
          $valueReconstructor
        )
      ).cast<$nativeKeyName, $nativeValueName>()
    ''';
  } else if (type is InterfaceType) {
    final element = type.element3;
    final nativeName = element.name3!;
    if (_manualReconstructionClasses.contains(nativeName)) {
      logic = '_reconstruct$nativeName(runtime, $valueIdentifier as \$Instance)';
    } else if (element is EnumElement2) {
      logic = '_reconstruct$nativeName(runtime, $valueIdentifier as \$Instance)';
    } else if (element is ClassElement2) {
      if (element.isAbstract) {
        if (nativeName == 'Widget') {
          logic = '_reconstructWidget(runtime, $valueIdentifier as \$Instance)';
        } else if (nativeName == 'Font') {
          logic = '_reconstructFont(runtime, $valueIdentifier as \$Instance)';
        } else if (nativeName == 'TableColumnWidth') {
          logic = '_reconstructTableColumnWidth(runtime, $valueIdentifier as \$Instance)';
        } else if (nativeName == 'Uint8List') {
          logic = 'Uint8List.fromList(($valueIdentifier as \$List).\$value.map((e) => (e as \$int).\$value).toList())';
        } else {
          logic = "throw UnimplementedError('Cannot reconstruct abstract type $nativeName without a dispatcher')";
        }
      } else {
        logic = '_reconstruct$nativeName(runtime, $valueIdentifier as \$Instance)';
      }
    } else {
      logic = '$valueIdentifier?.\$reified';
    }
  } else {
    logic = '$valueIdentifier?.\$reified';
  }

  if (isNullable) {
    return '$valueIdentifier == \$null() ? null : ($logic)';
  }
  return logic;
}
