import 'package:analyzer/dart/element/element2.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:code_builder/code_builder.dart' as cb;
import 'package:collection/collection.dart';
import 'package:dart_style/dart_style.dart';

const Set<String> _manualReconstructionClasses = {
  'PageSection',
  'PageLayout',
  'Document',
  'MetadataMarker',
  'Font',
  'TableColumnWidth',
  'TtfFont',
  'Image',
  '_BuiltInFont',
};

String generateJsReconstructorFile(List<ClassElement2> proxyableClasses, List<EnumElement2> proxyableEnums) {
  final library = cb.Library((b) {
    b.directives.add(cb.Directive.partOf('package:typesetting_prototype/eval/reconstruct_document_js.dart'));

    for (final enumElement in proxyableEnums) {
      b.body.add(_generateEnumReconstructor(enumElement));
    }

    final widgetClasses = <ClassElement2>[];
    for (final classElement in proxyableClasses) {
      if (_manualReconstructionClasses.contains(classElement.name3) || classElement.isAbstract) {
        continue;
      }
      b.body.add(_generateClassReconstructor(classElement, proxyableClasses, proxyableEnums));

      if (classElement.allSupertypes.any((t) => t.element3.name3 == 'Widget')) {
        widgetClasses.add(classElement);
      }
    }

    b.body.add(_generateWidgetDispatcher(widgetClasses));
  });

  final emitter = cb.DartEmitter(useNullSafetySyntax: true, orderDirectives: true);
  final code = library.accept(emitter).toString();

  final header = '''
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/generate_js_reconstructor.dart

// ignore_for_file: unused_element, unnecessary_cast

''';

  return DartFormatter(languageVersion: DartFormatter.latestLanguageVersion).format('$header\n\n$code');
}

cb.Method _generateWidgetDispatcher(List<ClassElement2> widgetClasses) {
  final builder = cb.MethodBuilder()
    ..name = 'reconstructWidget'
    ..returns = cb.refer('Widget')
    ..requiredParameters.add(
      cb.Parameter(
        (p) => p
          ..name = 'instance'
          ..type = cb.refer('JSObject'),
      ),
    );

  final switchBody = StringBuffer()
    ..writeln("final type = (getProperty<JSString>(instance, '_type')!).toDart;")
    ..writeln('switch (type) {');

  for (final classElement in widgetClasses.sorted((a, b) => a.name3!.compareTo(b.name3!))) {
    final nativeName = classElement.name3!;
    final scriptName = 'Script$nativeName';
    final funcName = '_reconstruct$nativeName';
    switchBody.writeln("  case '$scriptName': return $funcName(instance);");
  }
  switchBody
    ..writeln("  case 'ScriptImage': return reconstructImage(instance);")
    ..writeln("  case 'ScriptMetadataMarker': return reconstructMetadataMarker(instance);");

  switchBody
    ..writeln("  default: throw 'Unknown script widget type: \$type';")
    ..writeln('}');

  builder.body = cb.Code(switchBody.toString());
  return builder.build();
}

cb.Method _generateEnumReconstructor(EnumElement2 enumElement) {
  final nativeName = enumElement.name3!;
  return cb.Method((b) {
    b
      ..name = '_reconstruct$nativeName'
      ..returns = cb.refer(nativeName)
      ..requiredParameters.add(
        cb.Parameter(
          (p) => p
            ..name = 'value'
            ..type = cb.refer('String'),
        ),
      )
      ..body = cb.Code('return $nativeName.values.byName(value);');
  });
}

cb.Method _generateClassReconstructor(
  ClassElement2 classElement,
  List<ClassElement2> allProxyClasses,
  List<EnumElement2> allProxyEnums,
) {
  final nativeName = classElement.name3!;
  final returnType = cb.refer(nativeName);

  final builder = cb.MethodBuilder()
    ..name = '_reconstruct$nativeName'
    ..returns = returnType
    ..requiredParameters.add(
      cb.Parameter(
        (p) => p
          ..name = 'instance'
          ..type = cb.refer('JSObject'),
      ),
    );

  final constructors = classElement.constructors2.where((c) => !c.isPrivate).toList();
  if (constructors.isEmpty) {
    builder.body = cb.Code("throw UnimplementedError('Cannot reconstruct $nativeName: no public constructors');");
    return builder.build();
  }

  var constructor =
      constructors.firstWhereOrNull((c) => !c.isFactory && (c.name3 ?? '').isEmpty) ??
      constructors.firstWhereOrNull((c) => !c.isFactory) ??
      constructors.first;

  final bodyLines = <cb.Code>[];
  final paramAssignments = <String>[];

  for (final param in constructor.formalParameters) {
    final paramName = param.name3!;
    final paramType = param.type;
    final isNullable = paramType.nullabilitySuffix == NullabilitySuffix.question;

    final jsValueVar = '${paramName}JS';
    final jsType = _getJsInteropType(paramType);
    bodyLines.add(cb.Code("final $jsValueVar = getProperty<$jsType>(instance, '$paramName');"));

    final reconstructionLogic = _buildItemReconstructionLogic(jsValueVar, paramType, allProxyClasses, allProxyEnums);

    if (isNullable) {
      bodyLines.add(cb.Code("final $paramName = $jsValueVar == null ? null : $reconstructionLogic;"));
    } else {
      bodyLines.add(cb.Code("final $paramName = $reconstructionLogic;"));
    }

    if (param.isNamed) {
      paramAssignments.add('$paramName: $paramName');
    } else {
      paramAssignments.add(paramName);
    }
  }

  final ctorName = constructor.name3!;
  final constructorName = (ctorName.isEmpty || ctorName == 'new') ? '' : '.$ctorName';
  final returnStatement = cb.Code('return $nativeName$constructorName(${paramAssignments.join(', ')});');
  bodyLines.add(returnStatement);

  builder.body = cb.Block.of(bodyLines);
  return builder.build();
}

String _buildItemReconstructionLogic(
  String itemIdentifier,
  DartType type,
  List<ClassElement2> allProxyClasses,
  List<EnumElement2> allProxyEnums,
) {
  final id = itemIdentifier;

  if (type.isDartCoreString) return '($id as JSString).toDart';
  if (type.isDartCoreInt) return '($id as JSNumber).toDartInt';
  if (type.isDartCoreDouble) return '($id as JSNumber).toDartDouble';
  if (type.isDartCoreBool) return '($id as JSBoolean).toDart';

  if (type.isDartCoreList && type is InterfaceType) {
    final genericType = type.typeArguments.first;
    final itemReconstructor = _buildItemReconstructionLogic('e', genericType, allProxyClasses, allProxyEnums);
    return '($id as JSArray).toDart.map((e) => $itemReconstructor).toList()';
  }

  if (type.isDartCoreMap && type is InterfaceType) {
    final keyType = type.typeArguments[0];
    final valueType = type.typeArguments[1];
    final nativeKeyType = keyType.getDisplayString();
    final nativeValueType = valueType.getDisplayString();
    final keyRecon = keyType.isDartCoreInt ? 'int.parse(keyString)' : 'keyString';
    final valueRecon = _buildItemReconstructionLogic('jsValue', valueType, allProxyClasses, allProxyEnums);

    return '''
      (() {
        final dartMap = <$nativeKeyType, $nativeValueType>{};
        final jsMap = $id as JSObject;
        for (final key in _jsObjectKeys(jsMap).toDart) {
          final keyString = (key as JSString).toDart;
          final jsValue = jsMap.getProperty(keyString.toJS);
          dartMap[$keyRecon] = (jsValue == null ? null : $valueRecon) as $nativeValueType;
        }
        return dartMap;
      })()
    ''';
  }

  if (type is InterfaceType) {
    final element = type.element3;
    final nativeName = element.name3!;
    if (element is EnumElement2) {
      return '_reconstruct$nativeName(($id as JSString).toDart)';
    }
    if (element is ClassElement2) {
      if (nativeName == 'Widget') return 'reconstructWidget($id as JSObject)';
      if (nativeName == 'Uint8List') {
        return 'Uint8List.fromList(($id as JSArray<JSNumber>).toDart.map((e) => e.toDartInt).toList())';
      }
      if (_manualReconstructionClasses.contains(nativeName)) return 'reconstruct$nativeName($id as JSObject)';
      return '_reconstruct$nativeName($id as JSObject)';
    }
  }
  return '_convertJSAnyToDart($id)';
  // return "throw UnimplementedError('Cannot reconstruct type: ${type.getDisplayString(withNullability: false)}')";
}

String _getJsInteropType(DartType type) {
  if (type.isDartCoreString) return 'JSString';
  if (type.isDartCoreInt || type.isDartCoreDouble) return 'JSNumber';
  if (type.isDartCoreBool) return 'JSBoolean';
  if (type.isDartCoreList) return 'JSArray';
  if (type.isDartCoreMap) return 'JSObject';
  if (type is InterfaceType) {
    if (type.element3 is EnumElement2) {
      return 'JSString';
    }
    return 'JSObject';
  }
  return 'JSAny';
}
