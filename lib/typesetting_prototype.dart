import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

import '../geometry/geometry.dart';
import '../geometry/decoration.dart';
import '../text/text.dart';
import '../text/font.dart';
import '../style/style.dart';
import '../document/page.dart';

export '../geometry/geometry.dart';
export '../geometry/decoration.dart';
export '../document/page.dart';
import '../document/metadata.dart';
export '../text/text.dart';
export '../document/document.dart';
export '../document/metadata.dart';
export '../image/image.dart';
export '../style/style.dart';
export '../text/font.dart';
export '../layout/table.dart';

class LayoutContext {
  final pw.Context pwContext;
  final BoxConstraints constraints;
  final List<MetadataRecord> metadata;

  const LayoutContext({required this.metadata, required this.pwContext, required this.constraints});

  LayoutContext copyWith({BoxConstraints? constraints, List<MetadataRecord>? metadata}) {
    return LayoutContext(
      pwContext: pwContext,
      constraints: constraints ?? this.constraints,
      metadata: metadata ?? this.metadata,
    );
  }
}

class PaintingContext {
  final pw.Context pdfContext;
  final PdfGraphics canvas;
  final double pageHeight;
  PaintingContext(this.pdfContext, this.canvas, {required this.pageHeight});
}

abstract class RenderNode {
  RenderNode? parent;
  Size _size = Size.zero;
  Size get size => _size;
  set size(s) => _size = s;
  BoxConstraints? constraints;
  LayoutContext? layoutContext;

  LayoutResult layout(LayoutContext context) {
    layoutContext = context;
    constraints = context.constraints;
    final result = performLayout();
    _size = result.size;
    return result;
  }

  /// The method to override for custom layout logic.
  ///
  /// Subclasses must override this method to calculate their size based on the
  /// constraints provided by the parent. This method should only handle
  /// layout for content that is treated as an atomic, non-breakable block.
  ///
  /// If your node needs to break across pages, see the [RenderSlice] mixin.
  ///
  /// The implementation must Calculate its size based on `_constraints`.
  /// and return a `LayoutResult` containing this new size and any relevant
  /// `MetadataRecord`s generated by this node or its children.
  LayoutResult performLayout();

  void paint(PaintingContext context, Offset offset);

  LineBreakSettings getLineBreakSettings() {
    RenderNode? current = this;
    while (current != null) {
      if (current is RenderLineBreakConfiguration) {
        return current.settings;
      }
      current = current.parent;
    }
    return LineBreakSettings.defaultSettings;
  }

  static void printTree(RenderNode node, {String indent = '', bool isLast = true}) {
    final marker = isLast ? '└─' : '├─';
    final type = node.runtimeType;
    final hasParent = node.parent != null ? 'P' : 'x';
    String details = '($hasParent)';
    if (node is RenderRichText) {
      //todo: fix
      details += node.spans.first.text;
    } else if (node is RenderLineBreakConfiguration) {
      details += ' mode: ${node.settings.mode}';
    }

    print('$indent$marker $type $details');
    final childIndent = indent + (isLast ? '    ' : '│   ');
    if (node is ContainerRenderNodeMixin) {
      final children = node.children;
      for (var i = 0; i < children.length; i++) {
        printTree(children[i], indent: childIndent, isLast: i == children.length - 1);
      }
    } else if (node is RenderObjectWithChildMixin && node.child != null) {
      printTree(node.child!, indent: childIndent, isLast: true);
    }
  }
}

class SliceLayoutContext {
  final pw.Context pwContext;
  final BoxConstraints constraints;
  final double availableHeight;
  final List<MetadataRecord> metadata;
  const SliceLayoutContext({
    required this.pwContext,
    required this.constraints,
    required this.availableHeight,
    required this.metadata,
  });
}

class PositionedPrimitive {
  final RenderNode node;
  final Offset offset;
  PositionedPrimitive(this.node, this.offset);
}

class LayoutResult {
  final Size size;
  final List<MetadataRecord> metadata;

  const LayoutResult({required this.size, this.metadata = const []});

  static const LayoutResult zero = LayoutResult(size: Size.zero);
}

class SliceLayoutResult {
  final List<PositionedPrimitive> paintedPrimitives;
  final Size consumedSize;
  final RenderNode? remainder;
  final List<MetadataRecord> metadata;

  const SliceLayoutResult({
    required this.paintedPrimitives,
    required this.consumedSize,
    this.remainder,
    this.metadata = const [],
  });
}

/// A mixin for a `RenderNode` that can be split across multiple pages.
///
/// `RenderSlice` defines a contract for nodes that can be partially rendered on
/// one page, with the remainder being passed on to the next. This  enables
/// pagination for widgets like `Flow`, `Text`, and `MultiColumnFlow`.
///
/// A parent that supports pagination (like `RenderFlow`) will call `layoutSlice()`
/// on its children instead of the standard `layout()`.
///
/// ## The Slicing Contract
///
///  `layoutSlice()`  receives a
/// `SliceLayoutContext` which contains the `availableHeight` on the
/// current page. It must then determine what portion of its content
/// (if any) can fit within that height.
///
/// It returns a `SliceLayoutResult`, which communicates the outcome to the parent:
/// - `paintedPrimitives`: A list of the simple, atomic `RenderNode`s that did fit
///   and should be painted on the current page, along with their relative offsets.
/// - `consumedSize`: The total size occupied by the `paintedPrimitives` on this page.
/// - `remainder`: An object representing the content that *did not* fit. This will
///   be another `RenderNode` (usually a new instance of the same class with the
///   remaining content) that the parent will attempt to lay out on the next page.
///   If all content fit, this is `null`.
/// - `metadata`: A list of `MetadataRecord`s discovered within the portion of
///   the content that was laid out on this page.
///
/// A class that uses `RenderSlice` must still implement `performLayout()` to handle
/// cases where it is placed inside a non-paginating parent (like a `RenderRow`).
mixin RenderSlice on RenderNode {
  /// Lays out a portion of this node's content that fits within a given vertical space.
  ///
  /// See [RenderSlice] for more details.
  SliceLayoutResult layoutSlice(SliceLayoutContext context);
}

mixin RenderObjectWithChildMixin on RenderNode {
  RenderNode? _child;
  RenderNode? get child => _child;
  set child(RenderNode? value) {
    if (_child != null) _child!.parent = null;
    _child = value;
    if (_child != null) {
      _child!.parent = this;
    }
  }
}

mixin ContainerRenderNodeMixin on RenderNode {
  final List<RenderNode> _children = [];
  List<RenderNode> get children => List.unmodifiable(_children);

  void add(RenderNode child) {
    _children.add(child);
    child.parent = this;
  }

  void addAll(List<RenderNode> children) {
    for (final child in children) {
      _children.add(child);
      child.parent = this;
    }
  }

  void clear() {
    _children.clear();
  }
}

class RenderPadding extends RenderNode with RenderObjectWithChildMixin, RenderSlice {
  final EdgeInsets padding;
  RenderPadding(this.padding);

  @override
  LayoutResult performLayout() {
    if (child == null) {
      _size = constraints!.constrain(Size(padding.horizontal, padding.vertical));
      return LayoutResult(size: _size);
    }
    final innerConstraints = constraints!.deflate(padding);
    child!.layout(layoutContext!.copyWith(constraints: innerConstraints));
    final childSize = child!.size;
    _size = constraints!.constrain(Size(childSize.width + padding.horizontal, childSize.height + padding.vertical));
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    if (child != null) {
      child!.paint(context, offset + Offset(padding.left, padding.top));
    }
  }

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    final verticalPadding = padding.vertical;
    if (context.availableHeight < verticalPadding) {
      return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this);
    }

    if (child == null) {
      _size = context.constraints.constrain(Size(padding.horizontal, padding.vertical));
      if (_size.height <= context.availableHeight) {
        return SliceLayoutResult(
          paintedPrimitives: [PositionedPrimitive(this, Offset.zero)],
          consumedSize: _size,
          remainder: null,
        );
      } else {
        return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this);
      }
    }

    if (child is RenderSlice) {
      final childContext = SliceLayoutContext(
        pwContext: context.pwContext,
        constraints: context.constraints.deflate(padding),
        availableHeight: context.availableHeight - verticalPadding,
        metadata: context.metadata,
      );

      final childResult = (child as RenderSlice).layoutSlice(childContext);

      final List<PositionedPrimitive> transformedPrimitives = [
        for (final p in childResult.paintedPrimitives)
          PositionedPrimitive(p.node, p.offset + Offset(padding.left, padding.top)),
      ];
      final consumedSize = Size(
        childResult.consumedSize.width + padding.horizontal,
        childResult.consumedSize.height + verticalPadding,
      );
      final RenderNode? remainder = childResult.remainder != null
          ? (RenderPadding(padding)
              ..child = childResult.remainder
              ..parent = parent)
          : null;
      return SliceLayoutResult(
        paintedPrimitives: transformedPrimitives,
        consumedSize: consumedSize,
        remainder: remainder,
        metadata: childResult.metadata,
      );
    } else {
      final innerConstraints = context.constraints.deflate(padding);
      final childLayoutContext = LayoutContext(
        pwContext: context.pwContext,
        constraints: innerConstraints,
        metadata: context.metadata,
      );

      child!.layout(childLayoutContext);
      final childSize = child!.size;
      final totalHeight = childSize.height + padding.vertical;

      if (totalHeight <= context.availableHeight) {
        final selfSize = Size(childSize.width + padding.horizontal, totalHeight);
        _size = context.constraints.constrain(selfSize);

        return SliceLayoutResult(
          paintedPrimitives: [PositionedPrimitive(this, Offset.zero)],
          consumedSize: _size,
          remainder: null,
        );
      } else {
        return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this);
      }
    }
  }
}

class RenderSizedBox extends RenderNode with RenderObjectWithChildMixin {
  final double? width;
  final double? height;
  RenderSizedBox({this.width, this.height});

  @override
  LayoutResult performLayout() {
    if (child != null) {
      final childConstraints = BoxConstraints(
        minWidth: 0,
        maxWidth: width ?? constraints!.maxWidth,
        minHeight: 0,
        maxHeight: height ?? constraints!.maxHeight,
      );
      child!.layout(layoutContext!.copyWith(constraints: childConstraints));
      _size = constraints!.constrain(Size(width ?? child!.size.width, height ?? child!.size.height));
    } else {
      _size = constraints!.constrain(Size(width ?? 0.0, height ?? 0.0));
    }
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    child?.paint(context, offset);
  }
}

class RenderColumn extends RenderNode with ContainerRenderNodeMixin {
  final CrossAxisAlignment crossAxisAlignment;
  final MainAxisAlignment mainAxisAlignment;

  RenderColumn({this.crossAxisAlignment = CrossAxisAlignment.start, this.mainAxisAlignment = MainAxisAlignment.start});

  double _totalChildHeight = 0;

  @override
  LayoutResult performLayout() {
    double childrenHeight = 0;
    double maxChildWidth = 0;
    final parentConstraints = constraints!;
    final bool shrinkWrapWidth = crossAxisAlignment == CrossAxisAlignment.start;

    final double columnWidth = shrinkWrapWidth ? 0 : parentConstraints.maxWidth;

    final List<MetadataRecord> allMetadata = [];

    final List<MetadataRecord> metadataSoFar = [];

    for (final child in children) {
      final childLayoutContext = layoutContext!.copyWith(
        constraints: BoxConstraints(maxWidth: parentConstraints.maxWidth),
        metadata: [...layoutContext!.metadata, ...metadataSoFar],
      );

      final childResult = child.layout(childLayoutContext);
      if (childResult.size.width > maxChildWidth) {
        maxChildWidth = childResult.size.width;
      }
      childrenHeight += childResult.size.height;
      metadataSoFar.addAll(childResult.metadata);
    }
    allMetadata.addAll(metadataSoFar);

    final double finalWidth = shrinkWrapWidth ? maxChildWidth : columnWidth;

    if (crossAxisAlignment == CrossAxisAlignment.stretch) {
      allMetadata.clear();
      metadataSoFar.clear();
      childrenHeight = 0;

      final stretchConstraints = BoxConstraints(minWidth: finalWidth, maxWidth: finalWidth);

      for (final child in children) {
        final stretchLayoutContext = layoutContext!.copyWith(
          constraints: stretchConstraints,
          metadata: [...layoutContext!.metadata, ...metadataSoFar],
        );

        final childResult = child.layout(stretchLayoutContext);
        childrenHeight += childResult.size.height;

        metadataSoFar.addAll(childResult.metadata);
      }
      allMetadata.addAll(metadataSoFar);
    }

    _totalChildHeight = childrenHeight;

    final double finalHeight = childrenHeight.clamp(parentConstraints.minHeight, parentConstraints.maxHeight);

    final finalSize = parentConstraints.constrain(Size(finalWidth, finalHeight));

    return LayoutResult(size: finalSize, metadata: allMetadata);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    final double startY = switch (mainAxisAlignment) {
      MainAxisAlignment.start => 0,
      MainAxisAlignment.center => (_size.height - _totalChildHeight) / 2,
      MainAxisAlignment.end => _size.height - _totalChildHeight,
    };

    double currentY = startY;

    for (final child in children) {
      final double dx = switch (crossAxisAlignment) {
        CrossAxisAlignment.start || CrossAxisAlignment.stretch => 0,
        CrossAxisAlignment.center => (_size.width - child.size.width) / 2,
        CrossAxisAlignment.end => _size.width - child.size.width,
      };
      child.paint(context, offset + Offset(dx, currentY));
      currentY += child.size.height;
    }
  }
}

class RenderFlowFill extends RenderNode with RenderObjectWithChildMixin, RenderSlice {
  @override
  LayoutResult performLayout() {
    // This method is not expected to be called directly as this widget is
    // used within the top level of a RenderFlow
    if (child != null) {
      final result = child!.layout(layoutContext!);
      return LayoutResult(size: result.size);
    }
    return LayoutResult(size: Size.zero);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    if (child != null) {
      child!.paint(context, offset);
    }
  }

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    final fillHeight = context.availableHeight;
    if (fillHeight <= 0) {
      _size = Size.zero;
      return SliceLayoutResult(
        paintedPrimitives: [],
        consumedSize: Size.zero,
        remainder: null, // Consumes nothing, but is "done".
        //This state should not occur as Flow automatically moves to the next page
      );
    }

    _size = Size(context.constraints.maxWidth, fillHeight);
    constraints = context.constraints;
    layoutContext = LayoutContext(
      pwContext: context.pwContext,
      constraints: context.constraints,
      metadata: context.metadata,
    );

    if (child != null) {
      final childConstraints = BoxConstraints(
        minWidth: _size.width,
        maxWidth: _size.width,
        minHeight: _size.height,
        maxHeight: _size.height,
      );

      final childLayoutContext = LayoutContext(
        pwContext: context.pwContext,
        constraints: childConstraints,
        metadata: context.metadata,
      );
      child!.layout(childLayoutContext);
    }

    return SliceLayoutResult(
      paintedPrimitives: [PositionedPrimitive(this, Offset.zero)],
      consumedSize: _size,
      remainder: null,
    );
  }
}

class RenderKeepTogether extends RenderNode with RenderSlice {
  RenderNode? firstChild;
  RenderNode? secondChild;

  @override
  LayoutResult performLayout() {
    // This is not expected to be called directly in a flow layout.
    _size = Size.zero;
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {}

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    if (firstChild == null || secondChild == null) {
      final child = firstChild ?? secondChild;
      if (child is RenderSlice) {
        return child.layoutSlice(context);
      }
      return const SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero);
    }

    final firstChildLayoutContext = LayoutContext(
      pwContext: context.pwContext,
      constraints: context.constraints,
      metadata: context.metadata,
    );
    final firstChildResult = firstChild!.layout(firstChildLayoutContext);
    final firstChildSize = firstChildResult.size;
    final firstChildMetadata = firstChildResult.metadata;

    if (firstChildSize.height > context.availableHeight) {
      return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this);
    }

    if (secondChild is! RenderSlice) {
      print('The second child of KeepTogether must be a sliceable widget (e.g., Text, Flow, MultiColumnFlow)');
      throw TypeError();
    }

    final heightAfterFirst = context.availableHeight - firstChildSize.height;
    final secondChildMeasurementContext = SliceLayoutContext(
      pwContext: context.pwContext,
      constraints: context.constraints,
      availableHeight: heightAfterFirst,
      metadata: context.metadata,
    );

    final measurementResult = (secondChild as RenderSlice).layoutSlice(secondChildMeasurementContext);

    final needsPageBreak = measurementResult.consumedSize.height == 0 && measurementResult.remainder != null;

    if (needsPageBreak) {
      return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this);
    }

    final List<PositionedPrimitive> placedThisSlice = [];
    placedThisSlice.add(PositionedPrimitive(firstChild!, Offset.zero));

    for (final p in measurementResult.paintedPrimitives) {
      placedThisSlice.add(PositionedPrimitive(p.node, p.offset + Offset(0, firstChildSize.height)));
    }

    final consumedHeight = firstChildSize.height + measurementResult.consumedSize.height;
    final consumedSize = Size(context.constraints.maxWidth, consumedHeight);
    final RenderNode? finalRemainder = measurementResult.remainder;
    finalRemainder?.parent = parent;

    final combinedMetadata = [...firstChildMetadata, ...measurementResult.metadata];

    return SliceLayoutResult(
      paintedPrimitives: placedThisSlice,
      consumedSize: consumedSize,
      remainder: finalRemainder,
      metadata: combinedMetadata,
    );
  }
}

class RenderRow extends RenderNode with ContainerRenderNodeMixin {
  @override
  LayoutResult performLayout() {
    final List<RenderNode> nonExpanded = [];
    final List<RenderExpanded> expanded = [];
    final List<MetadataRecord> allMetadata = [];
    int totalFlex = 0;

    for (final child in children) {
      if (child is RenderExpanded) {
        expanded.add(child);
        totalFlex += child.flex;
      } else {
        nonExpanded.add(child);
      }
    }

    double usedWidth = 0;
    double maxHeight = 0;
    final parentConstraints = constraints!;
    final childLayoutContext = layoutContext!;

    for (final child in nonExpanded) {
      final childResult = child.layout(childLayoutContext);
      allMetadata.addAll(childResult.metadata);
      usedWidth += child.size.width;
      if (child.size.height > maxHeight) {
        maxHeight = child.size.height;
      }
    }

    final remainingWidth = (parentConstraints.maxWidth - usedWidth).clamp(0.0, double.infinity);

    if (totalFlex > 0) {
      for (final child in expanded) {
        final expandedWidth = remainingWidth * child.flex / totalFlex;
        final expandedConstraints = BoxConstraints(minWidth: expandedWidth, maxWidth: expandedWidth);

        final childResult = child.layout(childLayoutContext.copyWith(constraints: expandedConstraints));
        allMetadata.addAll(childResult.metadata);
        usedWidth += child.size.width;
        if (child.size.height > maxHeight) {
          maxHeight = child.size.height;
        }
      }
    }
    _size = parentConstraints.constrain(Size(usedWidth, maxHeight));
    return LayoutResult(size: _size, metadata: allMetadata);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    double currentX = 0;
    for (final child in children) {
      child.paint(context, offset + Offset(currentX, 0));
      currentX += child.size.width;
    }
  }
}

class RenderExpanded extends RenderNode with RenderObjectWithChildMixin {
  final int flex;
  RenderExpanded({this.flex = 1});

  @override
  LayoutResult performLayout() {
    if (child != null) {
      child!.layout(layoutContext!);
      _size = child!.size;
    } else {
      _size = constraints!.constrain(Size.zero);
    }
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    child?.paint(context, offset);
  }
}

class RenderRepeater extends RenderNode {
  final String text;
  final Font font;
  final double fontSize;
  final double lineHeight;

  RenderRepeater(this.text, {required this.font, required this.fontSize, required this.lineHeight});

  String _repeatedText = '';

  @override
  LayoutResult performLayout() {
    if (text.isEmpty || constraints!.maxWidth <= 0) {
      _size = Size.zero;
      _repeatedText = '';
      return LayoutResult(size: _size);
    }

    final pdfFont = FontManager.getFont(font, layoutContext!.pwContext);
    final singleMetric = pdfFont.stringMetrics(text) * fontSize;
    final fixedLineHeight = pdfFont.emptyLineHeight * fontSize * lineHeight;

    if (singleMetric.width <= 0) {
      _size = Size(0, fixedLineHeight);
      _repeatedText = '';
      return LayoutResult(size: _size);
    }

    final count = (constraints!.maxWidth / singleMetric.width).floor();
    _repeatedText = text * count;

    final fullMetrics = pdfFont.stringMetrics(_repeatedText) * fontSize;
    _size = Size(fullMetrics.width, fixedLineHeight);
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    if (_repeatedText.isEmpty) return;

    final pageHeight = context.pageHeight;
    final PdfFont pdfFont = FontManager.getFont(font, context.pdfContext);
    final y = pageHeight - offset.dy - (pdfFont.ascent * fontSize);
    context.canvas.drawString(pdfFont, fontSize, _repeatedText, offset.dx, y);
  }
}

class RenderFlow extends RenderNode with ContainerRenderNodeMixin, RenderSlice {
  @override
  LayoutResult performLayout() {
    double y = 0;
    double maxWidth = 0;
    final List<MetadataRecord> allMetadata = [];

    for (final child in children) {
      final childResult = child.layout(layoutContext!);
      y += childResult.size.height;
      if (childResult.size.width > maxWidth) {
        maxWidth = childResult.size.width;
      }
      allMetadata.addAll(childResult.metadata);
    }
    _size = Size(maxWidth, y);
    return LayoutResult(size: _size, metadata: allMetadata);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    double y = 0;
    for (final child in children) {
      child.paint(context, offset + Offset(0, y));
      y += child.size.height;
    }
  }

  @override
  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    final List<PositionedPrimitive> placedThisSlice = [];
    final List<RenderNode> nodesToLayout = List.of(children);
    final List<MetadataRecord> metadataThisSlice = [];
    double currentY = 0;

    while (nodesToLayout.isNotEmpty) {
      final node = nodesToLayout.removeAt(0);
      final availableHeight = context.availableHeight - currentY;

      if (availableHeight <= 1e-9) {
        nodesToLayout.insert(0, node);
        break;
      }

      final combinedMetadataForChild = [...context.metadata, ...metadataThisSlice];
      final SliceLayoutResult sliceResult;

      if (node is RenderSlice) {
        final sliceContext = SliceLayoutContext(
          pwContext: context.pwContext,
          constraints: context.constraints,
          availableHeight: availableHeight,
          metadata: combinedMetadataForChild,
        );
        sliceResult = node.layoutSlice(sliceContext);
      } else {
        // Treat non-sliceable nodes by attempting a full layout.
        final childLayoutContext = LayoutContext(
          pwContext: context.pwContext,
          constraints: context.constraints,
          metadata: combinedMetadataForChild,
        );
        final LayoutResult childResult = node.layout(childLayoutContext);

        if (node.size.height <= availableHeight) {
          // It fits completely.
          sliceResult = SliceLayoutResult(
            paintedPrimitives: [PositionedPrimitive(node, Offset.zero)],
            consumedSize: node.size,
            remainder: null,
            metadata: childResult.metadata,
          );
        } else {
          if (currentY < 1e-9) {
            //This currently does not handle the case where we are
            //in a nested Flow at the first child, and the nested
            //flow will get more room on the next page, which would
            //allow the child to be laid out.
            throw Exception(
              'Layout Error: A widget of type ${node.runtimeType.toString()} '
              'is taller (${node.size.height.toStringAsFixed(1)}pt) than the '
              'available page height (${context.availableHeight.toStringAsFixed(1)}pt). '
              'This widget cannot be split across pages and is too large to fit on a '
              'single page.',
            );
          }

          sliceResult = SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: node);
        }
      }
      metadataThisSlice.addAll(sliceResult.metadata);

      // If the child produced nothing for this page but has a remainder,
      // it means it wants a full fresh page. Break the loop.
      if (sliceResult.paintedPrimitives.isEmpty && sliceResult.remainder != null) {
        nodesToLayout.insert(0, sliceResult.remainder!);
        break;
      }

      // If we got something to paint, position it and update our Y-offset.
      if (sliceResult.paintedPrimitives.isNotEmpty) {
        for (final p in sliceResult.paintedPrimitives) {
          placedThisSlice.add(PositionedPrimitive(p.node, p.offset + Offset(0, currentY)));
        }
        currentY += sliceResult.consumedSize.height;
      }

      // If there's a remainder from a partially-laid-out child, put it in
      // the queue for the next page and break.
      if (sliceResult.remainder != null) {
        nodesToLayout.insert(0, sliceResult.remainder!);
        break;
      }
    }

    // If there are any nodes left in the queue, they become the remainder.
    final RenderNode? finalRemainder = nodesToLayout.isNotEmpty
        ? (RenderFlow()
            .._children.addAll(nodesToLayout)
            ..parent = parent)
        : null;

    return SliceLayoutResult(
      paintedPrimitives: placedThisSlice,
      consumedSize: Size(context.constraints.maxWidth, currentY),
      remainder: finalRemainder,
      metadata: metadataThisSlice,
    );
  }
}

///This Widget may be removed in favor of RenderMultiColumnFlow soon
class RenderMultiColumnBlock extends RenderNode with ContainerRenderNodeMixin {
  final int columnCount;
  final double columnSpacing;
  final List<PositionedPrimitive> _positionedPrimitives = [];

  RenderMultiColumnBlock({required this.columnCount, required this.columnSpacing});

  @override
  LayoutResult performLayout() {
    _positionedPrimitives.clear();
    final availableWidth = constraints!.maxWidth;
    final totalSpacing = columnSpacing * (columnCount - 1);
    final columnWidth = (availableWidth - totalSpacing) / columnCount;

    if (columnWidth <= 0 || columnCount <= 0) {
      _size = Size(availableWidth, 0);
      return LayoutResult(size: _size);
    }

    final List<RenderNode> allPrimitives = [];
    final List<RenderNode> nodesToLayout = List.of(children);
    final columnConstraints = BoxConstraints(maxWidth: columnWidth);

    final sliceContext = SliceLayoutContext(
      pwContext: layoutContext!.pwContext,
      constraints: columnConstraints,
      availableHeight: double.infinity,
      //TODO: make multicolumnblock metadata passing actually work.
      metadata: layoutContext!.metadata,
    );

    final regularLayoutContext = layoutContext!.copyWith(constraints: columnConstraints);

    while (nodesToLayout.isNotEmpty) {
      final node = nodesToLayout.removeAt(0);

      if (node is RenderSlice) {
        final result = node.layoutSlice(sliceContext);
        allPrimitives.addAll(result.paintedPrimitives.map((p) => p.node));

        if (result.remainder != null) {
          nodesToLayout.insert(0, result.remainder!);
        }
      } else {
        node.layout(regularLayoutContext);
        allPrimitives.add(node);
      }
    }

    if (allPrimitives.isEmpty) {
      _size = Size.zero;
      return LayoutResult(size: _size);
    }

    final double totalContentHeight = allPrimitives.fold(0.0, (sum, node) => sum + node.size.height);
    final double targetColumnHeight = totalContentHeight / columnCount;
    var targetColumnHeights = List.filled(columnCount, targetColumnHeight);

    var columnHeights = _balanceItr(columnWidth, allPrimitives, targetColumnHeights);

    final initialPrimitives = List.of(_positionedPrimitives);
    final initialColumnHeights = List.of(columnHeights);
    final smallestNode = allPrimitives.reduce((a, b) => a.size.height < b.size.height ? a : b);

    // This is a heuristic
    if (columnHeights.last >= columnHeights.first + smallestNode.size.height) {
      targetColumnHeights = List.filled(columnCount, targetColumnHeight);
      targetColumnHeights[0] += smallestNode.size.height;
      _positionedPrimitives.clear();
      final rebalancedColumnHeights = _balanceItr(columnWidth, allPrimitives, targetColumnHeights);

      final initialDifference = (initialColumnHeights.first - initialColumnHeights.last).abs();
      final rebalancedDifference = (rebalancedColumnHeights.first - rebalancedColumnHeights.last).abs();

      if (rebalancedDifference > initialDifference) {
        _positionedPrimitives
          ..clear()
          ..addAll(initialPrimitives);
        columnHeights = initialColumnHeights;
      } else {
        columnHeights = rebalancedColumnHeights;
      }
    }

    final maxColumnY = columnHeights.reduce((a, b) => a > b ? a : b);
    _size = Size(availableWidth, maxColumnY);
    return LayoutResult(size: _size);
  }

  List<double> _balanceItr(double columnWidth, List<RenderNode> allPrimitives, List<double> targetColumnHeights) {
    int itemIndex = 0;
    List<double> columnHeights = List.filled(columnCount, 0.0);

    for (int col = 0; col < columnCount; col++) {
      final colX = col * (columnWidth + columnSpacing);
      double currentColumnY = 0;

      while (itemIndex < allPrimitives.length) {
        final node = allPrimitives[itemIndex];
        final nodeHeight = node.size.height;

        if (col < columnCount - 1) {
          final currentDistance = (currentColumnY - targetColumnHeights[col]).abs();
          final nextDistance = (currentColumnY + nodeHeight - targetColumnHeights[col]).abs();

          if (currentColumnY > 0 && nextDistance > currentDistance) {
            break;
          }
        }

        _positionedPrimitives.add(PositionedPrimitive(node, Offset(colX, currentColumnY)));
        currentColumnY += nodeHeight;
        itemIndex++;
      }
      columnHeights[col] = currentColumnY;
    }

    while (columnHeights.length < columnCount) {
      columnHeights.add(0.0);
    }

    return columnHeights;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    for (final primitive in _positionedPrimitives) {
      primitive.node.paint(context, offset + primitive.offset);
    }
  }
}

class RenderMultiColumnFlow extends RenderNode with ContainerRenderNodeMixin, RenderSlice {
  final int columnCount;
  final double columnSpacing;

  RenderMultiColumnFlow({required this.columnCount, required this.columnSpacing});

  void _mergeMetadata(List<MetadataRecord> target, List<MetadataRecord> source) {
    target.addAll(source);
  }

  @override
  LayoutResult performLayout() {
    _size = Size.zero;
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {}

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    final List<RenderNode> nodesToLayout = List.of(children);
    final List<MetadataRecord> metadataThisSlice = [];

    final List<RenderNode> primitivesForThisPage = [];
    int currentColumn = 0;
    double currentY = 0;
    final columnWidth = (context.constraints.maxWidth - (columnSpacing * (columnCount - 1))) / columnCount;
    final columnConstraints = BoxConstraints(maxWidth: columnWidth);
    bool shouldBreak = false;

    while (nodesToLayout.isNotEmpty && !shouldBreak) {
      final node = nodesToLayout.removeAt(0);
      if (node is! RenderSlice) throw TypeError();

      final availableColumnHeight = context.availableHeight - currentY;
      final sliceContext = SliceLayoutContext(
        pwContext: context.pwContext,
        constraints: columnConstraints,
        availableHeight: availableColumnHeight,
        metadata: context.metadata,
      );
      final result = node.layoutSlice(sliceContext);

      _mergeMetadata(metadataThisSlice, result.metadata);

      if (result.paintedPrimitives.isEmpty && result.remainder != null) {
        currentColumn++;
        if (currentColumn >= columnCount) {
          shouldBreak = true;
          nodesToLayout.insert(0, node);
        } else {
          currentY = 0;
          nodesToLayout.insert(0, node);
        }
        continue;
      }

      if (result.paintedPrimitives.isNotEmpty) {
        primitivesForThisPage.addAll(result.paintedPrimitives.map((p) => p.node));
        currentY += result.consumedSize.height;
      }

      if (result.remainder != null) {
        nodesToLayout.insert(0, result.remainder!);
      }
    }

    final List<PositionedPrimitive> placedThisSlice = [];
    if (primitivesForThisPage.isNotEmpty) {
      final double totalContentHeight = primitivesForThisPage.fold(0.0, (sum, node) => sum + node.size.height);
      final double targetColumnHeight = totalContentHeight / columnCount;
      int itemIndex = 0;

      for (int col = 0; col < columnCount; col++) {
        final colX = col * (columnWidth + columnSpacing);
        double currentColumnY = 0;

        while (itemIndex < primitivesForThisPage.length) {
          final node = primitivesForThisPage[itemIndex];
          final nodeHeight = node.size.height;

          // Use the "closest-fit" logic unless it's the last column
          if (col < columnCount - 1) {
            final currentDistance = (currentColumnY - targetColumnHeight).abs();
            final nextDistance = (currentColumnY + nodeHeight - targetColumnHeight).abs();

            if (currentColumnY > 0 && nextDistance > currentDistance) {
              break;
            }
          }

          placedThisSlice.add(PositionedPrimitive(node, Offset(colX, currentColumnY)));
          currentColumnY += nodeHeight;
          itemIndex++;
        }
      }
    }

    final RenderNode? finalRemainder = nodesToLayout.isNotEmpty
        ? (RenderMultiColumnFlow(columnCount: columnCount, columnSpacing: columnSpacing)
            .._children.addAll(nodesToLayout)
            ..parent = parent)
        : null;

    double consumedHeight = 0;
    if (placedThisSlice.isNotEmpty) {
      consumedHeight = placedThisSlice.map((p) => p.offset.dy + p.node.size.height).reduce((a, b) => a > b ? a : b);
    }

    return SliceLayoutResult(
      paintedPrimitives: placedThisSlice,
      consumedSize: Size(context.constraints.maxWidth, consumedHeight),
      remainder: finalRemainder,
      metadata: metadataThisSlice,
    );
  }
}

class RenderSyncedColumns extends RenderNode with RenderSlice {
  final List<RenderNode> _topChildren = [];
  final List<RenderNode> _bottomChildren = [];
  final int topColumnCount;
  final double topColumnSpacing;
  final int bottomColumnCount;
  final double bottomColumnSpacing;
  final double spacing;

  RenderSyncedColumns({
    required this.topColumnCount,
    this.topColumnSpacing = 10.0,
    required this.bottomColumnCount,
    this.bottomColumnSpacing = 10.0,
    this.spacing = 10.0,
  });

  void addTop(RenderNode child) => _topChildren.add(child);
  void addBottom(RenderNode child) => _bottomChildren.add(child);

  @override
  LayoutResult performLayout() {
    _size = Size.zero;
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {}

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    assert(_topChildren.length == _bottomChildren.length);
    final List<RenderNode> topNodesForThisPage = [];
    final List<RenderNode> bottomNodesForThisPage = [];
    int itemsProcessed = 0;

    final simulationLayoutContext = LayoutContext(
      pwContext: context.pwContext,
      constraints: context.constraints,
      metadata: context.metadata,
    );

    for (int i = 0; i < _topChildren.length; i++) {
      final tempTopItems = [...topNodesForThisPage, _topChildren[i]];
      final tempBottomItems = [...bottomNodesForThisPage, _bottomChildren[i]];

      // this method is technically slow but hasn't been a problem yet
      final tempTopBlock = RenderMultiColumnBlock(columnCount: topColumnCount, columnSpacing: topColumnSpacing)
        ..parent = this
        ..addAll(tempTopItems)
        ..layout(simulationLayoutContext);

      final tempBottomBlock = RenderMultiColumnBlock(columnCount: bottomColumnCount, columnSpacing: bottomColumnSpacing)
        ..parent = this
        ..addAll(tempBottomItems)
        ..layout(simulationLayoutContext);

      final predictedHeight = tempTopBlock.size.height + spacing + tempBottomBlock.size.height;

      if (predictedHeight <= context.availableHeight) {
        topNodesForThisPage.add(_topChildren[i]);
        bottomNodesForThisPage.add(_bottomChildren[i]);
        itemsProcessed++;
      } else {
        break;
      }
    }

    if (itemsProcessed == 0) {
      return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this);
    }

    final List<PositionedPrimitive> placedThisSlice = [];
    final finalTopBlock = RenderMultiColumnBlock(columnCount: topColumnCount, columnSpacing: topColumnSpacing)
      ..parent = this
      ..addAll(topNodesForThisPage)
      ..layout(simulationLayoutContext);

    placedThisSlice.add(PositionedPrimitive(finalTopBlock, Offset.zero));

    final finalBottomBlock = RenderMultiColumnBlock(columnCount: bottomColumnCount, columnSpacing: bottomColumnSpacing)
      ..parent = this
      ..addAll(bottomNodesForThisPage)
      ..layout(simulationLayoutContext);

    final bottomOffset = Offset(0, finalTopBlock.size.height + spacing);
    placedThisSlice.add(PositionedPrimitive(finalBottomBlock, bottomOffset));

    final consumedHeight = finalTopBlock.size.height + spacing + finalBottomBlock.size.height;
    final consumedSize = Size(context.constraints.maxWidth, consumedHeight);

    RenderSyncedColumns? finalRemainder;
    if (itemsProcessed < _topChildren.length) {
      finalRemainder = RenderSyncedColumns(
        topColumnCount: topColumnCount,
        topColumnSpacing: topColumnSpacing,
        bottomColumnCount: bottomColumnCount,
        bottomColumnSpacing: bottomColumnSpacing,
        spacing: spacing,
      );
      finalRemainder._topChildren.addAll(_topChildren.sublist(itemsProcessed));
      finalRemainder._bottomChildren.addAll(_bottomChildren.sublist(itemsProcessed));
      finalRemainder.parent = parent;
    }

    return SliceLayoutResult(
      paintedPrimitives: placedThisSlice,
      consumedSize: consumedSize,
      remainder: finalRemainder,
      metadata: [],
    );
  }
}

class RenderResetPageNumber extends RenderNode with RenderSlice {
  final PageNumberSettings settings;
  RenderResetPageNumber({required this.settings});

  static const String metadataKey = '__pageNumberReset';

  @override
  LayoutResult performLayout() {
    _size = Size.zero;
    return LayoutResult(
      size: Size.zero,
      metadata: [MetadataRecord(key: metadataKey, value: settings)],
    );
  }

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    return SliceLayoutResult(
      paintedPrimitives: const [],
      consumedSize: Size.zero,
      remainder: null,
      metadata: [MetadataRecord(key: metadataKey, value: settings)],
    );
  }

  @override
  void paint(PaintingContext context, Offset offset) {}
}

// Widgets

abstract class Widget {
  const Widget();
  RenderNode createRenderNode();
}

class PageLayout extends Widget {
  final PageSection? header;
  final PageSection? footer;
  final List<Widget> body;
  final Widget Function(List<FootnoteItem>)? footnoteBuilder;
  const PageLayout({this.header, this.footer, this.body = const [], this.footnoteBuilder});
  @override
  RenderNode createRenderNode() {
    final bodyFlow = RenderFlow();
    for (final widgetChild in body) {
      bodyFlow.add(widgetChild.createRenderNode());
    }
    return RenderPageLayout(
      header: header,
      footer: footer,
      body: bodyFlow,
      footnoteBuilder: footnoteBuilder ?? _defaultFootnoteBuilder,
    );
  }
}

Widget _defaultFootnoteBuilder(List<FootnoteItem> items) {
  return DecoratedBox(
    decoration: const BoxDecoration(
      border: Border(top: BorderSide(width: 0.5, color: Color.black)),
    ),
    child: SizedBox(
      width: double.infinity,
      child: Padding(
        padding: const EdgeInsets.only(top: 5, left: 10, right: 10),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: items
              .map(
                (item) => Padding(
                  padding: const EdgeInsets.only(bottom: 2),
                  child: Text('${item.footnoteNumber}. ${item.content}', fontSize: 9),
                ),
              )
              .toList(),
        ),
      ),
    ),
  );
}

class Padding extends Widget {
  final EdgeInsets padding;
  final Widget child;
  const Padding({required this.padding, required this.child});
  @override
  RenderNode createRenderNode() {
    final renderPadding = RenderPadding(padding);
    (renderPadding).child = child.createRenderNode();
    return renderPadding;
  }
}

class SizedBox extends Widget {
  final double? width;
  final double? height;
  final Widget? child;

  const SizedBox({this.width, this.height, this.child});
  const SizedBox.shrink() : width = 0.0, height = 0.0, child = null;
  @override
  RenderNode createRenderNode() {
    final renderObject = RenderSizedBox(width: width, height: height);
    if (child != null) {
      (renderObject as RenderObjectWithChildMixin).child = child!.createRenderNode();
    }
    return renderObject;
  }
}

class Column extends Widget {
  final List<Widget> children;
  final CrossAxisAlignment crossAxisAlignment;
  final MainAxisAlignment mainAxisAlignment;

  const Column({
    this.children = const [],
    this.crossAxisAlignment = CrossAxisAlignment.start,
    this.mainAxisAlignment = MainAxisAlignment.start,
  });

  @override
  RenderNode createRenderNode() {
    final renderColumn = RenderColumn(crossAxisAlignment: crossAxisAlignment, mainAxisAlignment: mainAxisAlignment);
    for (final widgetChild in children) {
      renderColumn.add(widgetChild.createRenderNode());
    }
    return renderColumn;
  }
}

class FlowFill extends Widget {
  final Widget child;
  const FlowFill({required this.child});

  @override
  RenderNode createRenderNode() {
    final renderObject = RenderFlowFill();
    renderObject.child = child.createRenderNode();
    return renderObject;
  }
}

class KeepTogether extends Widget {
  /// The widget that must appear on the same page as the start of the [second] widget.
  /// This is typically treated as an atomic block (e.g., a title).
  final Widget first;

  /// The widget that follows the [first] widget. It must be sliceable (e.g. Text, Flow).
  final Widget second;

  const KeepTogether({required this.first, required this.second});

  @override
  RenderNode createRenderNode() {
    final renderObject = RenderKeepTogether();
    renderObject.firstChild = first.createRenderNode();
    renderObject.secondChild = second.createRenderNode();
    return renderObject;
  }
}

class Row extends Widget {
  final List<Widget> children;
  const Row({this.children = const []});
  @override
  RenderNode createRenderNode() {
    final renderRow = RenderRow();
    for (final widgetChild in children) {
      renderRow.add(widgetChild.createRenderNode());
    }
    return renderRow;
  }
}

class Expanded extends Widget {
  final Widget child;
  final int flex;
  const Expanded({required this.child, this.flex = 1});

  @override
  RenderNode createRenderNode() {
    final renderObject = RenderExpanded(flex: flex);
    renderObject.child = child.createRenderNode();
    return renderObject;
  }
}

class Repeater extends Widget {
  final String text;
  final double fontSize;
  final Font? font;
  final double lineHeight;

  const Repeater(this.text, {this.fontSize = 12, this.font, this.lineHeight = 1.3});

  @override
  RenderNode createRenderNode() {
    return RenderRepeater(text, font: font ?? Font.helvetica, fontSize: fontSize, lineHeight: lineHeight);
  }
}

class LineBreakConfiguration extends Widget {
  final LineBreakMode mode;
  final Widget child;

  const LineBreakConfiguration({required this.mode, required this.child});

  @override
  RenderNode createRenderNode() {
    final renderObject = RenderLineBreakConfiguration(LineBreakSettings(mode: mode));
    renderObject.child = child.createRenderNode();
    return renderObject;
  }
}

class RichText extends Widget {
  final List<TextSpan> children;
  final double fontSize;
  final Font? font;
  final double lineHeight;

  const RichText({required this.children, this.fontSize = 12, this.font, this.lineHeight = 1.3});

  @override
  RenderNode createRenderNode() {
    return RenderRichText(children, fontSize: fontSize, lineHeight: lineHeight);
  }
}

class Text extends Widget {
  final String text;
  final TextStyle style;
  final double? fontSize;
  final Font? font;
  final double lineHeight;

  const Text(this.text, {this.style = const TextStyle(), this.fontSize, this.font, this.lineHeight = 1.3});

  @override
  RenderNode createRenderNode() {
    final fontSizeStyle = TextStyle(fontSize: fontSize);
    late final List<TextSpan> child;
    if (font == null) {
      child = [TextSpan(text, style: style.merge(fontSizeStyle))];
    } else {
      child = [TextSpan(text, style: TextStyle.fromFont(font: font!).merge(style).merge(fontSizeStyle))];
    }
    return RenderRichText(child, fontSize: style.fontSize ?? 12, lineHeight: lineHeight);
  }
}

/// Layout information for footnotes discovered during layout.
class FootnoteLayoutInfo {
  /// The text content of the footnote.
  final String content;

  /// The position of the footnote marker within the laid-out body text.
  /// currently is not set correctly, but most of the architecture needed
  /// to support it is in place.
  double position;

  final int number;

  FootnoteLayoutInfo({required this.content, required this.position, required this.number});
}

class RenderFormattedText extends RenderNode with RenderObjectWithChildMixin, RenderSlice {
  final String text;
  final FontFamily fontFamily;
  final double fontSize;
  final double lineHeight;
  final Widget Function(List<Widget> richTexts)? builder;
  final double? paragraphIndent;
  final int newlinesForBreak;
  final bool indentFirstParagraph;

  RenderFormattedText(
    this.text, {
    required this.fontFamily,
    required this.fontSize,
    required this.lineHeight,
    this.builder,
    this.paragraphIndent,
    required this.indentFirstParagraph,
    required this.newlinesForBreak,
  });

  void _parseAndBuildChild(LayoutContext context) {
    final processedText = text.replaceAll('\t', '');
    final int startingFootnoteCount = context.metadata.where((r) => r.key == '__footnote').length;
    int localFootnoteCounter = 0;

    final List<String> paragraphs;
    if (newlinesForBreak <= 0) {
      final singleParagraph = processedText
          .split('\n')
          .map((line) => line.trim())
          .where((line) => line.isNotEmpty)
          .join(' ');
      paragraphs = [singleParagraph];
    } else {
      final paragraphSeparator = RegExp(r'([ \t]*\n){' + newlinesForBreak.toString() + r',}');
      paragraphs = processedText
          .split(paragraphSeparator)
          .map((p) {
            return p.split('\n').map((line) => line.trim()).where((line) => line.isNotEmpty).join(' ');
          })
          .where((p) => p.isNotEmpty)
          .toList();
    }

    final List<Widget> richTextWidgets = [];
    final baseStyle = TextStyle(fontFamily: fontFamily, fontSize: fontSize);
    final regex = RegExp(r'#(\w+)\[(.*?)\]', dotAll: true);

    for (final (paragraphIndex, paragraph) in paragraphs.indexed) {
      if (paragraph.trim().isEmpty) continue;

      final List<TextSpan> spans = [];
      int lastMatchEnd = 0;

      for (final match in regex.allMatches(paragraph)) {
        final precedingText = paragraph.substring(lastMatchEnd, match.start);
        if (precedingText.isNotEmpty) {
          spans.add(TextSpan(precedingText, style: baseStyle));
        }

        final tagName = match.group(1);
        final content = match.group(2) ?? '';

        switch (tagName) {
          case 'bold':
            spans.add(TextSpan(content, style: baseStyle.merge(const TextStyle(fontWeight: FontWeight.bold))));
            break;
          case 'italic':
            spans.add(TextSpan(content, style: baseStyle.merge(const TextStyle(fontStyle: FontStyle.italic))));
            break;
          case 'footnote':
            localFootnoteCounter++;
            final globalFootnoteNumber = startingFootnoteCount + localFootnoteCounter;
            final markerText = globalFootnoteNumber.toString();
            final footnoteInfo = FootnoteLayoutInfo(content: content, number: globalFootnoteNumber, position: 0.0);
            final record = MetadataRecord(key: '__footnote', value: footnoteInfo);
            spans.add(TextSpan(markerText, metadata: [record], style: baseStyle.merge(TextStyle.superscript)));
            break;
          default:
            spans.add(TextSpan(match.group(0)!, style: baseStyle));
        }
        lastMatchEnd = match.end;
      }

      if (lastMatchEnd < paragraph.length) {
        spans.add(TextSpan(paragraph.substring(lastMatchEnd), style: baseStyle));
      }

      if (spans.isNotEmpty && paragraphIndent != null && paragraphIndent! > 0) {
        if (indentFirstParagraph == true || paragraphIndex > 0) {
          final firstSpan = spans.first;
          final indentedStyle = firstSpan.style.merge(TextStyle(leftPadding: paragraphIndent!));
          spans[0] = TextSpan(firstSpan.text, style: indentedStyle, metadata: firstSpan.metadata);
        }
      }

      if (spans.isNotEmpty) {
        richTextWidgets.add(RichText(children: spans, fontSize: fontSize, lineHeight: lineHeight));
      }
    }

    final finalWidget = builder?.call(richTextWidgets) ?? Flow(children: richTextWidgets);

    child = finalWidget.createRenderNode();
    child!.parent = this;
  }

  @override
  LayoutResult performLayout() {
    _parseAndBuildChild(layoutContext!);
    final childResult = child!.layout(layoutContext!);
    return LayoutResult(size: childResult.size, metadata: childResult.metadata);
  }

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    _parseAndBuildChild(
      LayoutContext(pwContext: context.pwContext, constraints: context.constraints, metadata: context.metadata),
    );
    if (child is RenderSlice) {
      return (child as RenderSlice).layoutSlice(context);
    } else {
      final childLayoutContext = LayoutContext(
        pwContext: context.pwContext,
        constraints: context.constraints,
        metadata: context.metadata,
      );
      final childResult = child!.layout(childLayoutContext);
      if (childResult.size.height <= context.availableHeight) {
        return SliceLayoutResult(
          paintedPrimitives: [PositionedPrimitive(this, Offset.zero)],
          consumedSize: childResult.size,
          remainder: null,
          metadata: childResult.metadata,
        );
      } else {
        return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this, metadata: []);
      }
    }
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    child?.paint(context, offset);
  }
}

class FormattedText extends Widget {
  final String text;
  final double fontSize;
  final FontFamily? fontFamily;
  final double lineHeight;

  /// An optional builder that allows wrapping the parsed paragraphs
  /// in other layout widgets.
  /// If not provided, paragraphs will be placed in a vertical Flow.
  final Widget Function(List<Widget> richTexts)? builder;

  /// The amount of horizontal space to add to the beginning of each
  /// paragraph, creating an indent.
  final double? paragraphIndent;

  /// The number of consecutive newline characters required in the source
  /// text to trigger a new paragraph. Defaults to 1.
  /// A common value is 2, which allows for single newlines in the source
  /// for readability without creating a paragraph break in the output.
  final int newlinesForBreak;

  final bool indentFirstParagraph;

  const FormattedText(
    this.text, {
    this.fontSize = 12,
    this.fontFamily,
    this.lineHeight = 1.3,
    this.builder,
    this.paragraphIndent,
    this.newlinesForBreak = 1,
    this.indentFirstParagraph = false,
  });

  @override
  RenderNode createRenderNode() {
    return RenderFormattedText(
      text,
      fontFamily: fontFamily ?? FontFamily.helvetica,
      fontSize: fontSize,
      lineHeight: lineHeight,
      builder: builder,
      paragraphIndent: paragraphIndent,
      indentFirstParagraph: indentFirstParagraph,
      newlinesForBreak: newlinesForBreak,
    );
  }
}

class MetadataMarker extends Widget {
  final String key;
  final dynamic value;
  final Widget child;
  const MetadataMarker({required this.key, required this.value, required this.child});
  @override
  RenderNode createRenderNode() {
    final renderObject = RenderMetadataMarker(key: key, value: value);
    renderObject.child = child.createRenderNode();
    return renderObject;
  }
}

class Flow extends Widget {
  final List<Widget> children;
  const Flow({this.children = const []});
  @override
  RenderNode createRenderNode() {
    final renderFlow = RenderFlow();
    for (final widgetChild in children) {
      renderFlow.add(widgetChild.createRenderNode());
    }
    return renderFlow;
  }
}

class MultiColumn extends Widget {
  final int columnCount;
  final double columnSpacing;
  final List<Widget> children;

  const MultiColumn({this.columnCount = 2, this.columnSpacing = 10.0, this.children = const []});

  @override
  RenderNode createRenderNode() {
    final renderObject = RenderMultiColumnBlock(columnCount: columnCount, columnSpacing: columnSpacing);
    for (final child in children) {
      renderObject.add(child.createRenderNode());
    }
    return renderObject;
  }
}

class MultiColumnFlow extends Widget {
  final int columnCount;
  final double columnSpacing;
  final List<Widget> children;
  const MultiColumnFlow({this.columnCount = 2, this.columnSpacing = 10.0, this.children = const []});
  @override
  RenderNode createRenderNode() {
    final renderObject = RenderMultiColumnFlow(columnCount: columnCount, columnSpacing: columnSpacing);
    for (final child in children) {
      renderObject.add(child.createRenderNode());
    }
    return renderObject;
  }
}

class SyncedColumns extends Widget {
  final List<Widget> topChildren;
  final int topColumnCount;
  final double topColumnSpacing;
  final List<Widget> bottomChildren;
  final int bottomColumnCount;
  final double bottomColumnSpacing;
  final double spacing;

  const SyncedColumns({
    this.topChildren = const [],
    this.topColumnCount = 2,
    this.topColumnSpacing = 10.0,
    this.bottomChildren = const [],
    this.bottomColumnCount = 2,
    this.bottomColumnSpacing = 10.0,
    this.spacing = 20.0,
  });

  @override
  RenderNode createRenderNode() {
    final renderObject = RenderSyncedColumns(
      topColumnCount: topColumnCount,
      topColumnSpacing: topColumnSpacing,
      bottomColumnCount: bottomColumnCount,
      bottomColumnSpacing: bottomColumnSpacing,
      spacing: spacing,
    );
    for (final child in topChildren) {
      renderObject.addTop(child.createRenderNode());
    }
    for (final child in bottomChildren) {
      renderObject.addBottom(child.createRenderNode());
    }
    return renderObject;
  }
}

class RenderDecoratedBox extends RenderNode with RenderObjectWithChildMixin, RenderSlice {
  final BoxDecoration decoration;
  final bool isFirstSlice;

  RenderDecoratedBox(this.decoration, {this.isFirstSlice = true});

  @override
  LayoutResult performLayout() {
    if (child != null) {
      final borderDimensions = decoration.border?.dimensions ?? EdgeInsets.zero();
      final innerConstraints = constraints!.deflate(borderDimensions);
      final childLayoutContext = layoutContext!.copyWith(constraints: innerConstraints);
      final childResult = child!.layout(childLayoutContext);

      final totalSize = Size(
        childResult.size.width + borderDimensions.horizontal,
        childResult.size.height + borderDimensions.vertical,
      );
      size = constraints!.constrain(totalSize);
      return LayoutResult(size: size, metadata: childResult.metadata);
    }
    size = constraints!.constrain(Size.zero);
    return LayoutResult.zero;
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    final border = decoration.border;
    if (border != null) {
      final borderPainter = RenderPartialBorder(
        border,
        drawTop: true,
        drawLeft: true,
        drawRight: true,
        drawBottom: true,
      )..size = size;
      borderPainter.paint(context, offset);
    }
    if (child != null) {
      final borderDimensions = decoration.border?.dimensions ?? EdgeInsets.zero();
      child!.paint(context, offset + Offset(borderDimensions.left, borderDimensions.top));
    }
  }

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    final border = decoration.border;
    if (child == null || border == null || child is! RenderSlice) {
      final layoutContext = LayoutContext(
        pwContext: context.pwContext,
        constraints: context.constraints,
        metadata: context.metadata,
      );
      final result = layout(layoutContext);
      if (size.height <= context.availableHeight) {
        return SliceLayoutResult(
          paintedPrimitives: [PositionedPrimitive(this, Offset.zero)],
          consumedSize: size,
          metadata: result.metadata,
        );
      } else {
        return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this);
      }
    }

    final borderDimensions = border.dimensions;
    final childContext = SliceLayoutContext(
      pwContext: context.pwContext,
      constraints: context.constraints.deflate(borderDimensions),
      availableHeight: context.availableHeight - borderDimensions.vertical,
      metadata: context.metadata,
    );

    final childResult = (child as RenderSlice).layoutSlice(childContext);

    if (childResult.paintedPrimitives.isEmpty) {
      return SliceLayoutResult(
        paintedPrimitives: [],
        consumedSize: Size.zero,
        remainder: this,
        metadata: childResult.metadata,
      );
    }

    final consumedSize = Size(
      childResult.consumedSize.width + borderDimensions.horizontal,
      childResult.consumedSize.height + borderDimensions.vertical,
    );

    final bool hasRemainder = childResult.remainder != null;
    final borderPainter = RenderPartialBorder(
      border,
      drawTop: isFirstSlice,
      drawLeft: true,
      drawRight: true,
      drawBottom: !hasRemainder, // Draw bottom only if this is the last slice
      //TODO: allow the bottom border to be customized to show on all slices
    )..size = consumedSize;

    final childOffset = Offset(borderDimensions.left, borderDimensions.top);
    final transformedPrimitives = childResult.paintedPrimitives
        .map((p) => PositionedPrimitive(p.node, p.offset + childOffset))
        .toList();

    final allPrimitives = [PositionedPrimitive(borderPainter, Offset.zero), ...transformedPrimitives];

    final RenderNode? finalRemainder = hasRemainder
        ? (RenderDecoratedBox(decoration, isFirstSlice: false)
            ..child = childResult.remainder
            ..parent = parent)
        : null;

    return SliceLayoutResult(
      paintedPrimitives: allPrimitives,
      consumedSize: consumedSize,
      remainder: finalRemainder,
      metadata: childResult.metadata,
    );
  }
}

class DecoratedBox extends Widget {
  final BoxDecoration decoration;
  final Widget child;

  const DecoratedBox({required this.decoration, required this.child});

  @override
  RenderNode createRenderNode() {
    return RenderDecoratedBox(decoration)..child = child.createRenderNode();
  }
}

class Underline extends Widget {
  final Widget child;
  final Color color;
  final double thickness;

  const Underline({required this.child, this.color = Color.black, this.thickness = 1.0});

  @override
  RenderNode createRenderNode() {
    return DecoratedBox(
      decoration: BoxDecoration(
        border: Border(
          bottom: BorderSide(color: color, width: thickness),
        ),
      ),
      child: child,
    ).createRenderNode();
  }
}

/// An offset that describes a point within a rectangle.
///
/// The x and y values are represented as a fraction of the rectangle's width
/// and height. An Alignment of (0.0, 0.0) corresponds to the center of the
/// rectangle. An alignment of (-1.0, -1.0) corresponds to the top-left
/// corner, and (1.0, 1.0) corresponds to the bottom-right corner.
class Alignment {
  final double x;
  final double y;

  const Alignment(this.x, this.y);

  static const Alignment topLeft = Alignment(-1.0, -1.0);
  static const Alignment topCenter = Alignment(0.0, -1.0);
  static const Alignment topRight = Alignment(1.0, -1.0);
  static const Alignment centerLeft = Alignment(-1.0, 0.0);
  static const Alignment center = Alignment(0.0, 0.0);
  static const Alignment centerRight = Alignment(1.0, 0.0);
  static const Alignment bottomLeft = Alignment(-1.0, 1.0);
  static const Alignment bottomCenter = Alignment(0.0, 1.0);
  static const Alignment bottomRight = Alignment(1.0, 1.0);
}

/// A widget that aligns its child within itself and optionally sizes itself
/// based on the child's size.
///
/// By default, an `Align` widget will expand to fill the space given by its
/// parent, and then position its child within that space according to the
/// `alignment` property.
class Align extends Widget {
  final Alignment alignment;
  final Widget child;

  const Align({this.alignment = Alignment.center, required this.child});

  @override
  RenderNode createRenderNode() {
    final renderObject = RenderAlign(alignment: alignment);
    renderObject.child = child.createRenderNode();
    return renderObject;
  }
}

class RenderAlign extends RenderNode with RenderObjectWithChildMixin, RenderSlice {
  final Alignment alignment;

  RenderAlign({required this.alignment});

  @override
  LayoutResult performLayout() {
    if (child != null) {
      final childConstraints = constraints!.loosen();
      final childResult = child!.layout(layoutContext!.copyWith(constraints: childConstraints));
      final childSize = childResult.size;

      double selfWidth;
      if (constraints!.maxWidth == double.infinity) {
        selfWidth = childSize.width;
      } else {
        selfWidth = constraints!.maxWidth;
      }

      double selfHeight;
      if (constraints!.maxHeight == double.infinity) {
        selfHeight = childSize.height;
      } else {
        selfHeight = constraints!.maxHeight;
      }

      _size = Size(selfWidth, selfHeight);

      return LayoutResult(size: _size, metadata: childResult.metadata);
    }
    _size = constraints!.constrain(Size.zero);
    return LayoutResult(size: _size);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    if (child != null) {
      final childSize = child!.size;
      final double slackWidth = (_size.width - childSize.width).clamp(0.0, double.infinity);
      final double slackHeight = (_size.height - childSize.height).clamp(0.0, double.infinity);

      final double childX = slackWidth * (alignment.x + 1.0) / 2.0;
      final double childY = slackHeight * (alignment.y + 1.0) / 2.0;

      final childOffset = Offset(childX, childY);
      child!.paint(context, offset + childOffset);
    }
  }

  @override
  SliceLayoutResult layoutSlice(SliceLayoutContext context) {
    final layoutContext = LayoutContext(
      pwContext: context.pwContext,
      constraints: context.constraints,
      metadata: context.metadata,
    );
    final result = layout(layoutContext);

    if (size.height <= context.availableHeight) {
      return SliceLayoutResult(
        paintedPrimitives: [PositionedPrimitive(this, Offset.zero)],
        consumedSize: size,
        remainder: null,
        metadata: result.metadata,
      );
    } else {
      return SliceLayoutResult(paintedPrimitives: [], consumedSize: Size.zero, remainder: this, metadata: []);
    }
  }
}
